// Code generated by github.com/Yamashou/gqlgenc, DO NOT EDIT.

package domain

import (
	"encoding/json/jsontext"
	json "encoding/json/v2"
)

type UpdateUser struct {
	UpdateUser UpdateUser_UpdateUser "json:\"updateUser,omitempty,omitzero\""
}

func (t *UpdateUser) UnmarshalJSON(data []byte) error {
	var raw map[string]jsontext.Value
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	type Alias UpdateUser
	var aux Alias
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	*t = UpdateUser(aux)
	if value, ok := raw["updateUser"]; ok {
		if err := json.Unmarshal(value, &t.UpdateUser); err != nil {
			return err
		}
	}
	return nil
}
func (t *UpdateUser) GetUpdateUser() UpdateUser_UpdateUser {
	if t == nil {
		t = &UpdateUser{}
	}
	return t.UpdateUser
}

type UpdateUser_UpdateUser struct {
	User UpdateUser_UpdateUser_User "json:\"user,omitempty,omitzero\""
}

func (t *UpdateUser_UpdateUser) UnmarshalJSON(data []byte) error {
	var raw map[string]jsontext.Value
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	type Alias UpdateUser_UpdateUser
	var aux Alias
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	*t = UpdateUser_UpdateUser(aux)
	if value, ok := raw["user"]; ok {
		if err := json.Unmarshal(value, &t.User); err != nil {
			return err
		}
	}
	return nil
}

type UpdateUser_UpdateUser_User struct {
	Name string "json:\"name,omitempty,omitzero\""
}

func (t *UpdateUser_UpdateUser_User) UnmarshalJSON(data []byte) error {
	var raw map[string]jsontext.Value
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	type Alias UpdateUser_UpdateUser_User
	var aux Alias
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	*t = UpdateUser_UpdateUser_User(aux)
	if value, ok := raw["name"]; ok {
		if err := json.Unmarshal(value, &t.Name); err != nil {
			return err
		}
	}
	return nil
}

type UserFragment1 struct {
	User struct {
		Name string "json:\"name,omitempty,omitzero\""
	} "json:\"-\""
	Name    string                "json:\"name,omitempty,omitzero\""
	Profile UserFragment1_Profile "json:\"profile,omitempty,omitzero\""
}

type UserFragment1_Profile struct {
	PrivateProfile struct {
		Age *int "json:\"age\""
	} "json:\"-\""
	PublicProfile struct {
		Status Status "json:\"status,omitempty,omitzero\""
	} "json:\"-\""
}

func (t *UserFragment1_Profile) UnmarshalJSON(data []byte) error {
	var raw map[string]jsontext.Value
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	type Alias UserFragment1_Profile
	var aux Alias
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	*t = UserFragment1_Profile(aux)
	if err := json.Unmarshal(data, &t.PrivateProfile); err != nil {
		return err
	}
	if value, ok := raw["age"]; ok {
		if err := json.Unmarshal(value, &t.PrivateProfile.Age); err != nil {
			return err
		}
	}
	if err := json.Unmarshal(data, &t.PublicProfile); err != nil {
		return err
	}
	if value, ok := raw["status"]; ok {
		if err := json.Unmarshal(value, &t.PublicProfile.Status); err != nil {
			return err
		}
	}
	return nil
}

type UserFragment2 struct {
	Name string "json:\"name,omitempty,omitzero\""
}

func (t *UserFragment2) UnmarshalJSON(data []byte) error {
	var raw map[string]jsontext.Value
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	type Alias UserFragment2
	var aux Alias
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	*t = UserFragment2(aux)
	if value, ok := raw["name"]; ok {
		if err := json.Unmarshal(value, &t.Name); err != nil {
			return err
		}
	}
	return nil
}

type UserOperation struct {
	OptionalUser *UserOperation_OptionalUser "json:\"optionalUser\""
	User         UserOperation_User          "json:\"user,omitempty,omitzero\""
}

func (t *UserOperation) UnmarshalJSON(data []byte) error {
	var raw map[string]jsontext.Value
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	type Alias UserOperation
	var aux Alias
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	*t = UserOperation(aux)
	if value, ok := raw["optionalUser"]; ok {
		if err := json.Unmarshal(value, &t.OptionalUser); err != nil {
			return err
		}
	}
	if value, ok := raw["user"]; ok {
		if err := json.Unmarshal(value, &t.User); err != nil {
			return err
		}
	}
	return nil
}
func (t *UserOperation) GetOptionalUser() *UserOperation_OptionalUser {
	if t == nil {
		t = &UserOperation{}
	}
	return t.OptionalUser
}
func (t *UserOperation) GetUser() UserOperation_User {
	if t == nil {
		t = &UserOperation{}
	}
	return t.User
}

type UserOperation_OptionalUser struct {
	Name string "json:\"name,omitempty,omitzero\""
}

func (t *UserOperation_OptionalUser) UnmarshalJSON(data []byte) error {
	var raw map[string]jsontext.Value
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	type Alias UserOperation_OptionalUser
	var aux Alias
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	*t = UserOperation_OptionalUser(aux)
	if value, ok := raw["name"]; ok {
		if err := json.Unmarshal(value, &t.Name); err != nil {
			return err
		}
	}
	return nil
}
func (t *UserOperation_OptionalUser) GetName() string {
	if t == nil {
		t = &UserOperation_OptionalUser{}
	}
	return t.Name
}

type UserOperation_User struct {
	User struct {
		UserFragment2 "json:\"-\""
		Name          string "json:\"name,omitempty,omitzero\""
	} "json:\"-\""
	UserFragment1   "json:\"-\""
	UserFragment2   "json:\"-\""
	Address         UserOperation_User_Address          "json:\"address,omitempty,omitzero\""
	Name            string                              "json:\"name,omitempty,omitzero\""
	Name2           string                              "json:\"name2,omitempty,omitzero\""
	OptionalAddress *UserOperation_User_OptionalAddress "json:\"optionalAddress\""
	OptionalProfile *UserOperation_User_OptionalProfile "json:\"optionalProfile\""
	Profile         UserOperation_User_Profile          "json:\"profile,omitempty,omitzero\""
	Profile2        UserOperation_User_Profile2         "json:\"profile2,omitempty,omitzero\""
}

func (t *UserOperation_User) UnmarshalJSON(data []byte) error {
	var raw map[string]jsontext.Value
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	type Alias UserOperation_User
	var aux Alias
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	*t = UserOperation_User(aux)
	if value, ok := raw["address"]; ok {
		if err := json.Unmarshal(value, &t.Address); err != nil {
			return err
		}
	}
	if value, ok := raw["name"]; ok {
		if err := json.Unmarshal(value, &t.Name); err != nil {
			return err
		}
	}
	if value, ok := raw["name2"]; ok {
		if err := json.Unmarshal(value, &t.Name2); err != nil {
			return err
		}
	}
	if value, ok := raw["optionalAddress"]; ok {
		if err := json.Unmarshal(value, &t.OptionalAddress); err != nil {
			return err
		}
	}
	if value, ok := raw["optionalProfile"]; ok {
		if err := json.Unmarshal(value, &t.OptionalProfile); err != nil {
			return err
		}
	}
	if value, ok := raw["profile"]; ok {
		if err := json.Unmarshal(value, &t.Profile); err != nil {
			return err
		}
	}
	if value, ok := raw["profile2"]; ok {
		if err := json.Unmarshal(value, &t.Profile2); err != nil {
			return err
		}
	}
	if err := json.Unmarshal(data, &t.User); err != nil {
		return err
	}
	if value, ok := raw["name"]; ok {
		if err := json.Unmarshal(value, &t.User.Name); err != nil {
			return err
		}
	}
	if err := json.Unmarshal(data, &t.User.UserFragment2); err != nil {
		return err
	}
	if err := json.Unmarshal(data, &t.UserFragment1); err != nil {
		return err
	}
	if value, ok := raw["name"]; ok {
		if err := json.Unmarshal(value, &t.UserFragment1.Name); err != nil {
			return err
		}
	}
	if value, ok := raw["profile"]; ok {
		if err := json.Unmarshal(value, &t.UserFragment1.Profile); err != nil {
			return err
		}
	}
	if err := json.Unmarshal(data, &t.UserFragment1.User); err != nil {
		return err
	}
	if value, ok := raw["name"]; ok {
		if err := json.Unmarshal(value, &t.UserFragment1.User.Name); err != nil {
			return err
		}
	}
	if err := json.Unmarshal(data, &t.UserFragment2); err != nil {
		return err
	}
	if value, ok := raw["name"]; ok {
		if err := json.Unmarshal(value, &t.UserFragment2.Name); err != nil {
			return err
		}
	}
	return nil
}

type UserOperation_User_Address struct {
	PrivateAddress struct {
		Private bool   "json:\"private,omitempty,omitzero\""
		Street  string "json:\"street,omitempty,omitzero\""
	} "json:\"-\""
	PublicAddress struct {
		Public bool   "json:\"public,omitempty,omitzero\""
		Street string "json:\"street,omitempty,omitzero\""
	} "json:\"-\""
	Street string "json:\"street,omitempty,omitzero\""
}

func (t *UserOperation_User_Address) UnmarshalJSON(data []byte) error {
	var raw map[string]jsontext.Value
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	type Alias UserOperation_User_Address
	var aux Alias
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	*t = UserOperation_User_Address(aux)
	if value, ok := raw["street"]; ok {
		if err := json.Unmarshal(value, &t.Street); err != nil {
			return err
		}
	}
	if err := json.Unmarshal(data, &t.PrivateAddress); err != nil {
		return err
	}
	if value, ok := raw["private"]; ok {
		if err := json.Unmarshal(value, &t.PrivateAddress.Private); err != nil {
			return err
		}
	}
	if value, ok := raw["street"]; ok {
		if err := json.Unmarshal(value, &t.PrivateAddress.Street); err != nil {
			return err
		}
	}
	if err := json.Unmarshal(data, &t.PublicAddress); err != nil {
		return err
	}
	if value, ok := raw["public"]; ok {
		if err := json.Unmarshal(value, &t.PublicAddress.Public); err != nil {
			return err
		}
	}
	if value, ok := raw["street"]; ok {
		if err := json.Unmarshal(value, &t.PublicAddress.Street); err != nil {
			return err
		}
	}
	return nil
}

type UserOperation_User_OptionalAddress struct {
	PrivateAddress struct {
		Private bool   "json:\"private,omitempty,omitzero\""
		Street  string "json:\"street,omitempty,omitzero\""
	} "json:\"-\""
	PublicAddress struct {
		Public bool   "json:\"public,omitempty,omitzero\""
		Street string "json:\"street,omitempty,omitzero\""
	} "json:\"-\""
	Street string "json:\"street,omitempty,omitzero\""
}

func (t *UserOperation_User_OptionalAddress) UnmarshalJSON(data []byte) error {
	var raw map[string]jsontext.Value
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	type Alias UserOperation_User_OptionalAddress
	var aux Alias
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	*t = UserOperation_User_OptionalAddress(aux)
	if value, ok := raw["street"]; ok {
		if err := json.Unmarshal(value, &t.Street); err != nil {
			return err
		}
	}
	if err := json.Unmarshal(data, &t.PrivateAddress); err != nil {
		return err
	}
	if value, ok := raw["private"]; ok {
		if err := json.Unmarshal(value, &t.PrivateAddress.Private); err != nil {
			return err
		}
	}
	if value, ok := raw["street"]; ok {
		if err := json.Unmarshal(value, &t.PrivateAddress.Street); err != nil {
			return err
		}
	}
	if err := json.Unmarshal(data, &t.PublicAddress); err != nil {
		return err
	}
	if value, ok := raw["public"]; ok {
		if err := json.Unmarshal(value, &t.PublicAddress.Public); err != nil {
			return err
		}
	}
	if value, ok := raw["street"]; ok {
		if err := json.Unmarshal(value, &t.PublicAddress.Street); err != nil {
			return err
		}
	}
	return nil
}
func (t *UserOperation_User_OptionalAddress) GetPrivateAddress() struct {
	Private bool   "json:\"private,omitempty,omitzero\""
	Street  string "json:\"street,omitempty,omitzero\""
} {
	if t == nil {
		t = &UserOperation_User_OptionalAddress{}
	}
	return t.PrivateAddress
}
func (t *UserOperation_User_OptionalAddress) GetPublicAddress() struct {
	Public bool   "json:\"public,omitempty,omitzero\""
	Street string "json:\"street,omitempty,omitzero\""
} {
	if t == nil {
		t = &UserOperation_User_OptionalAddress{}
	}
	return t.PublicAddress
}
func (t *UserOperation_User_OptionalAddress) GetStreet() string {
	if t == nil {
		t = &UserOperation_User_OptionalAddress{}
	}
	return t.Street
}

type UserOperation_User_OptionalProfile struct {
	PrivateProfile struct {
		Age *int "json:\"age\""
	} "json:\"-\""
	PublicProfile struct {
		Status Status "json:\"status,omitempty,omitzero\""
	} "json:\"-\""
}

func (t *UserOperation_User_OptionalProfile) UnmarshalJSON(data []byte) error {
	var raw map[string]jsontext.Value
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	type Alias UserOperation_User_OptionalProfile
	var aux Alias
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	*t = UserOperation_User_OptionalProfile(aux)
	if err := json.Unmarshal(data, &t.PrivateProfile); err != nil {
		return err
	}
	if value, ok := raw["age"]; ok {
		if err := json.Unmarshal(value, &t.PrivateProfile.Age); err != nil {
			return err
		}
	}
	if err := json.Unmarshal(data, &t.PublicProfile); err != nil {
		return err
	}
	if value, ok := raw["status"]; ok {
		if err := json.Unmarshal(value, &t.PublicProfile.Status); err != nil {
			return err
		}
	}
	return nil
}
func (t *UserOperation_User_OptionalProfile) GetPrivateProfile() struct {
	Age *int "json:\"age\""
} {
	if t == nil {
		t = &UserOperation_User_OptionalProfile{}
	}
	return t.PrivateProfile
}
func (t *UserOperation_User_OptionalProfile) GetPublicProfile() struct {
	Status Status "json:\"status,omitempty,omitzero\""
} {
	if t == nil {
		t = &UserOperation_User_OptionalProfile{}
	}
	return t.PublicProfile
}

type UserOperation_User_Profile struct {
	PrivateProfile struct {
		Age *int "json:\"age\""
	} "json:\"-\""
	PublicProfile struct {
		Status Status "json:\"status,omitempty,omitzero\""
	} "json:\"-\""
}

func (t *UserOperation_User_Profile) UnmarshalJSON(data []byte) error {
	var raw map[string]jsontext.Value
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	type Alias UserOperation_User_Profile
	var aux Alias
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	*t = UserOperation_User_Profile(aux)
	if err := json.Unmarshal(data, &t.PrivateProfile); err != nil {
		return err
	}
	if value, ok := raw["age"]; ok {
		if err := json.Unmarshal(value, &t.PrivateProfile.Age); err != nil {
			return err
		}
	}
	if err := json.Unmarshal(data, &t.PublicProfile); err != nil {
		return err
	}
	if value, ok := raw["status"]; ok {
		if err := json.Unmarshal(value, &t.PublicProfile.Status); err != nil {
			return err
		}
	}
	return nil
}

type UserOperation_User_Profile2 struct {
	PrivateProfile struct {
		Age *int "json:\"age\""
	} "json:\"-\""
	PublicProfile struct {
		Status Status "json:\"status,omitempty,omitzero\""
	} "json:\"-\""
}

func (t *UserOperation_User_Profile2) UnmarshalJSON(data []byte) error {
	var raw map[string]jsontext.Value
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	type Alias UserOperation_User_Profile2
	var aux Alias
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	*t = UserOperation_User_Profile2(aux)
	if err := json.Unmarshal(data, &t.PrivateProfile); err != nil {
		return err
	}
	if value, ok := raw["age"]; ok {
		if err := json.Unmarshal(value, &t.PrivateProfile.Age); err != nil {
			return err
		}
	}
	if err := json.Unmarshal(data, &t.PublicProfile); err != nil {
		return err
	}
	if value, ok := raw["status"]; ok {
		if err := json.Unmarshal(value, &t.PublicProfile.Status); err != nil {
			return err
		}
	}
	return nil
}

const UpdateUserDocument = `mutation UpdateUser ($input: UpdateUserInput!) {
	updateUser(input: $input) {
		user {
			name
		}
	}
}
`
const UserOperationDocument = `query UserOperation {
	user {
		name
		name2: name
		profile {
			... on PublicProfile {
				status
			}
			... on PrivateProfile {
				age
			}
		}
		profile2: profile {
			... on PublicProfile {
				status
			}
			... on PrivateProfile {
				age
			}
		}
		optionalProfile {
			... on PublicProfile {
				status
			}
			... on PrivateProfile {
				age
			}
		}
		address {
			street
			... on PublicAddress {
				street
				public
			}
			... on PrivateAddress {
				street
				private
			}
		}
		optionalAddress {
			street
			... on PublicAddress {
				street
				public
			}
			... on PrivateAddress {
				street
				private
			}
		}
		... UserFragment1
		... UserFragment2
		... on User {
			name
			... UserFragment2
		}
	}
	optionalUser {
		name
	}
}
fragment UserFragment1 on User {
	name
	name
	... on User {
		name
	}
	profile {
		... on PublicProfile {
			status
		}
		... on PrivateProfile {
			age
		}
	}
}
fragment UserFragment2 on User {
	name
}
`

var DocumentOperationNames = map[string]string{
	UpdateUserDocument:    "UpdateUser",
	UserOperationDocument: "UserOperation",
}
